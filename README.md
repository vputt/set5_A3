# Задача A3. HyperMegaLogLog Pro Max++

Отчёт по реализации и анализу алгоритма **HyperLogLog** для оценки числа уникальных элементов в потоке данных (частотный момент $F_0$).

---

## Содержание

1. [Теория и постановка задачи](#1-теория-и-постановка-задачи)
2. [Этап 1. Инфраструктура](#2-этап-1-инфраструктура)
3. [Этап 2. Стандартный HyperLogLog](#3-этап-2-стандартный-hyperloglog)
4. [Эксперименты и графики](#4-эксперименты-и-графики)
5. [Этап 3. Анализ точности и стабильности](#5-этап-3-анализ-точности-и-стабильности)
6. [Этап 4. Усовершенствования HyperLogLog](#6-этап-4-усовершенствования-HyperLogLog)
7. [Структура проекта](#7-структура-проекта-и-запуск)

---

## 1. Теория и постановка задачи

В потоковой модели данные приходят последовательно, объём потока потенциально неограничен, а память алгоритма фиксирована и существенно меньше объёма данных. Для таких условий точный подсчёт числа различных элементов требует хранения всех уже встреченных ключей, что не масштабируется по памяти.

**Обозначения:**

* $F_0^t$ — число **различных** (уникальных) объектов в потоке к моменту времени $t$.
* $N_t$ — оценка этого числа, выдаваемая алгоритмом.

Алгоритм **HyperLogLog** — вероятностный метод оценки кардинальности множества, использующий $m = 2^B$ регистров и хеш‑функцию

$$
h: U \to {0, \dots, 2^{32}-1}.
$$

Элемент хешируется в 32‑битное значение, часть бит используется для выбора регистра, а по оставшимся битам оценивается позиция первой единицы. Агрегация значений регистров даёт оценку мощности множества.

Теоретическая стандартная относительная ошибка HyperLogLog составляет примерно

$$
\sigma_{\text{theor}} \approx \frac{1.04}{\sqrt{m}}.
$$

В задании предлагается сравнивать эмпирическую ошибку с диапазоном

$$
\sqrt{\frac{1.04}{2^B}} ;\text{–}; \sqrt{\frac{1.3}{2^B}}.
$$

---

## 2. Этап 1. Инфраструктура

### 2.1. Генератор потока `RandomStreamGen`

**Цель:** сгенерировать поток строк $S$ и уметь брать префикс потока, моделирующий момент времени $t$.

**Реализация генератора:**

* Строки длиной от 1 до 30 символов.
* Алфавит: латинские буквы верхнего и нижнего регистра, цифры `0–9`, символ `-`.
* Используется `std::mt19937_64` и равномерные распределения по длине и по алфавиту.
* Реализованы методы получения префикса по доле потока (5%, 10%, …, 100%) и по количеству элементов.

### 2.2. Хеш‑функция `HashFuncGen`

**Цель:** реализовать хеш‑функцию

$$
h: U \to {0, \dots, 2^{32}-1},
$$

чтобы значения хеша были близки к равномерным по 32‑битному диапазону.

В проекте использован 32‑битный FNV‑1a, который широко применяется как быстрый строковый хеш и подходит для потоковых экспериментов на случайных строках.

---

## 3. Этап 2. Стандартный HyperLogLog

### 3.1. Параметры и структура

Параметры алгоритма:

* $B$ — число бит для выбора регистра;
* $m = 2^B$ — число регистров $M[0, \dots, m-1]$.

Каждый регистр хранит максимум наблюдаемого значения $\rho$, связанного с числом ведущих нулей в «хвосте» хеша.

### 3.2. Обработка элемента

Для элемента $s$ вычисляется $x = h(s)$, затем:

1. Индекс регистра $\text{idx}$ берётся из старших $B$ бит 32‑битного хеша.

2. По оставшимся $32-B$ битам считается

   $$
   \rho = 1 + \text{leadingZeros}(\cdot).
   $$

3. Выполняется обновление

   $$
   M[\text{idx}] = \max(M[\text{idx}], \rho).
   $$

### 3.3. Формула оценки

После обработки потока оценка кардинальности вычисляется как

$$
Z = \left( \sum_{j=0}^{m-1} 2^{-M[j]} \right)^{-1},
$$

$$
E = \alpha_m \cdot m^2 \cdot Z,
$$

где $\alpha_m$ — нормировочная константа. Для $m \ge 128$ используется формула

$$
\alpha_m = \frac{0.7213}{1 + 1.079 / m}.
$$

В данной работе использовалась базовая версия оценки без дополнительных корректировок для малых и очень больших кардинальностей, чтобы исследовать поведение стандартного алгоритма.

### 3.4. Выбор $B$

В экспериментах использовано $B = 10$, то есть $m = 1024$ регистра. Теоретическая стандартная относительная ошибка при этом порядка

$$
\frac{1.04}{\sqrt{1024}} \approx 3.25%.
$$

Это соответствует ожидаемому диапазону из условия.

### 3.5. Точное значение $F_0^t$

Для каждого префикса потока точное количество уникальных элементов $F_0^t$ вычислялось через `std::unordered_set<std::string>` как размер множества элементов префикса. Это значение использовалось как эталон при сравнении с оценкой $N_t$.

---

## 4. Эксперименты и графики

### 4.1. Настройка

Сгенерированы 5 независимых потоков длиной 100 000 строк каждый. Рассматривались префиксы от 5% до 100% с шагом 5%. Для каждого префикса вычислялись $F_0^t$ и $N_t$.

Результаты сохранялись в `results_streams.csv`, а также агрегировались по потокам в `stats_by_ratio.csv` (среднее и стандартное отклонение оценки).

### 4.2. График №1: сравнение $N_t$ и $F_0^t$

Для каждого из пяти потоков показаны кривые точного числа уникальных элементов $F_0^t$ и оценки $N_t$ по мере роста доли обработанного потока. Визуально $N_t$ хорошо повторяет динамику $F_0^t$, а отклонения относительно масштаба осей невелики.

**Интерпретация:** алгоритм корректно отслеживает рост числа уникальных элементов и даёт оценки, близкие к истинным значениям.

### 4.3. Относительная оценка $N_t / F_0^t$

Для потока `stream_id = 0` построено отношение

$$
\frac{N_t}{F_0^t}
$$

в зависимости от доли потока. Отношение колеблется около 1 и находится примерно в диапазоне 0.97–1.06, а начиная с 20–30% становится более стабильным.

**Интерпретация:** характер колебаний соответствует вероятностной природе HyperLogLog и ожидаемой ошибке порядка нескольких процентов при $m = 1024$.

### 4.4. График №2: $E(N_t)$ и область $E(N_t) \pm \sigma_{N_t}$

Построен график средних по потокам значений: $\overline{F_0^t}$ (точное среднее), $E(N_t)$ (средняя оценка) и область неопределённости

$$
E(N_t) \pm \sigma_{N_t}.
$$

На всём диапазоне $t$ линия $E(N_t)$ идёт близко к $\overline{F_0^t}$, а закрашенная область остаётся узкой, что указывает на малый разброс результатов между потоками.

---

## 5. Этап 3. Анализ точности и стабильности

### 5.1. Сопоставление с теорией

При $B = 10$ ($m = 1024$) ожидаемая стандартная относительная ошибка порядка $3.25%$. По экспериментальным графикам видно, что отклонения оценки от истинного значения остаются в пределах нескольких процентов и не выходят за рамки порядка 6%.

Это качественно соответствует теоретическим границам

$$
\sqrt{\frac{1.04}{2^B}} ;\text{–}; \sqrt{\frac{1.3}{2^B}}.
$$

### 5.2. Стабильность и дисперсия

Полоса $E(N_t) \pm \sigma_{N_t}$ остаётся узкой по всей оси времени, что означает небольшой разброс оценок между потоками. Такое поведение согласуется с тем, что точность HyperLogLog определяется главным образом числом регистров $m$ и не ухудшается при увеличении длины потока.

### 5.3. Практические выводы по параметрам

Выбор $B = 10$ обеспечивает баланс между памятью (1024 регистра) и точностью на потоках длины $10^5$. Нормировочная константа $\alpha_m$ использована в стандартном виде для $m \ge 128$, что соответствует оригинальному анализу HyperLogLog.

---

## 6. Этап 4. Усовершенствования HyperLogLog

### 6.1. Идея улучшений

Для улучшенной версии алгоритма была добавлена «практическая» схема HyperLogLog, включающая коррекции для малых и очень больших кардинальностей.

Для малых кардинальностей используется *small-range correction* (LinearCounting): если сырая оценка

$$
E < \frac{5}{2} m
$$

и число нулевых регистров $V > 0$, то применяется формула

$$
E^* = m \ln \left( \frac{m}{V} \right).
$$

Для очень больших кардинальностей при 32-битном хеше применяется *large-range correction* (учёт коллизий хеша при приближении к $2^{32}$). Эта коррекция активируется при больших значениях $E$ и корректирует оценку через логарифмическую формулу, учитывающую насыщение пространства хешей.

Дополнительно была реализована оптимизация памяти: регистры хранятся в упакованном виде (*packed representation*), что позволяет уменьшить потребление памяти по сравнению с хранением каждого регистра отдельным байтом.

---

### 6.2. Почему на «больших данных» отличий почти нет

Сравнение стандартного и улучшенного алгоритмов выполнялось на шагах потока 5%, 10%, …, 100% от 100 000 элементов. В этом диапазоне графики стандартной и улучшенной версий визуально практически совпадают.

Причина заключается в том, что при $B = 10$ ($m = 1024$) порог малой коррекции

$$
\frac{5}{2} m \approx 2560
$$

быстро превышается уже на первых процентах потока. Поэтому LinearCounting практически не участвует в оценке при шагах от 5% и выше.

Large-range correction в рамках эксперимента также не проявляется, поскольку наблюдаемые кардинальности порядка $10^5$ существенно меньше диапазона, в котором начинают доминировать эффекты насыщения 32-битного хеша (порядка $2^{32}$).

---

### 6.3. Изменение сетки шагов (ratios)

Чтобы продемонстрировать эффект *small-range correction*, эксперимент был дополнен более ранними моментами времени (например, 1–4% потока), где доля пустых регистров $V$ ещё заметна, и LinearCounting оказывает влияние на итоговую оценку.

После добавления ранних шагов стало возможным наблюдать различие между стандартной и улучшенной оценками на самых первых точках, что видно на графике сравнения относительной оценки.

---

### 6.4. Анализ графиков (improved)

**Graph #1 (improved)** показывает, что оценка $N_t$ в улучшенной версии сохраняет линейный рост и остаётся близкой к точному значению $F_0^t$ на всём диапазоне шагов.

В сравнительном **Graph #1 (std vs improved)** линии стандартной и улучшенной версий практически накладываются друг на друга на средних и больших долях потока, что подтверждает одинаковое поведение алгоритмов в этом диапазоне.

**Relative estimate (std vs improved)** демонстрирует, что различия между версиями наиболее заметны на ранних шагах. Улучшенная версия ведёт себя стабильнее за счёт использования LinearCounting при малой кардинальности, тогда как стандартная версия может давать более резкие отклонения на первых точках.

Начиная с некоторого шага, когда кардинальность становится достаточно большой относительно $m$, обе кривые относительной оценки становятся практически идентичными. Это соответствует тому, что *small-range correction* перестаёт применяться после выхода за порог

$$
\frac{5}{2} m.
$$

**Graph #2 (improved)** показывает, что средняя оценка $E(N_t)$ идёт близко к среднему точному значению $\overline{F_0^t}$, а область

$$
E(N_t) \pm \sigma_{N_t}
$$

остаётся узкой.

На **Graph #2 (comparison: std vs improved)** области неопределённости для стандартной и улучшенной версий в основном перекрываются. Это означает, что в основном диапазоне кардинальностей улучшения практически не влияют на среднее поведение и дисперсию, а основной эффект улучшенной версии проявляется именно в зоне малых значений $t$.

---

### 6.5. Выводы по этапу 4

1. Добавленные *small-range* и *large-range* коррекции соответствуют общепринятой «практической» версии HyperLogLog: LinearCounting применяется при

   $$
   E < \frac{5}{2} m,
   $$

   а *large-range correction* — при приближении к границе пространства 32-битного хеша.

2. На исходной сетке шагов (от 5% потока) улучшенная и стандартная версии практически совпадают, поскольку *small-range correction* уже не активируется, а *large-range correction* для данного размера данных недостижима.

3. После добавления ранних шагов (1–4%) улучшенная версия демонстрирует более корректное поведение на самых малых префиксах потока за счёт LinearCounting, что видно по графику относительной оценки.

4. Оптимизация хранения регистров (*packed representation*) улучшает потребление памяти


---

## 7. Структура проекта

**Основные файлы проекта:**

* `RandomStreamGen.h/.cpp` — генерация потоков строк и получение префиксов.
* `HashFuncGen.h/.cpp` — хеш‑функция (FNV‑1a, 32‑бит).
* `HyperLogLog.h/.cpp` — стандартная реализация HyperLogLog (`add`, `estimate`, регистры в `std::vector<uint8_t>`).
* `HyperLogLogImproved.h/.cpp` — улучшенная версия HyperLogLog: small-range correction (LinearCounting), large-range correction (для 32‑битного хеша), упакованное хранение регистров (packed representation, несколько бит на регистр). [web:143][web:2]
* `ExactDistinct.h` — точный подсчёт $F_0^t$ через `std::unordered_set`.
* `main.cpp` — запуск экспериментов и формирование CSV для **двух** реализаций:  
  * стандартные файлы: `results_streams.csv`, `stats_by_ratio.csv`;  
  * улучшенные файлы: `results_streams_improved.csv`, `stats_by_ratio_improved.csv`.
* `plots_hll.py` — построение графиков по CSV для стандартной версии, улучшенной версии и их сравнения (std vs improved).
