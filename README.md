# Задача A3. HyperMegaLogLog Pro Max++

Отчёт по реализации и анализу алгоритма **HyperLogLog** для оценки числа уникальных элементов в потоке данных (частотный момент $F_0$).

---

## Содержание

1. [Теория и постановка задачи](#1-теория-и-постановка-задачи)
2. [Этап 1. Инфраструктура](#2-этап-1-инфраструктура)
3. [Этап 2. Стандартный HyperLogLog](#3-этап-2-стандартный-hyperloglog)
4. [Эксперименты и графики](#4-эксперименты-и-графики)
5. [Этап 3. Анализ точности и стабильности](#5-этап-3-анализ-точности-и-стабильности)
6. [Структура проекта и запуск](#6-структура-проекта-и-запуск)

---

## 1. Теория и постановка задачи

В потоковой модели данные приходят последовательно, объём потока потенциально неограничен, а память алгоритма фиксирована и существенно меньше объёма данных. Для таких условий точный подсчёт числа различных элементов требует хранения всех уже встреченных ключей, что не масштабируется по памяти.

**Обозначения:**

* $F_0^t$ — число **различных** (уникальных) объектов в потоке к моменту времени $t$.
* $N_t$ — оценка этого числа, выдаваемая алгоритмом.

Алгоритм **HyperLogLog** — вероятностный метод оценки кардинальности множества, использующий $m = 2^B$ регистров и хеш‑функцию

$$
h: U \to {0, \dots, 2^{32}-1}.
$$

Элемент хешируется в 32‑битное значение, часть бит используется для выбора регистра, а по оставшимся битам оценивается позиция первой единицы. Агрегация значений регистров даёт оценку мощности множества.

Теоретическая стандартная относительная ошибка HyperLogLog составляет примерно

$$
\sigma_{\text{theor}} \approx \frac{1.04}{\sqrt{m}}.
$$

В задании предлагается сравнивать эмпирическую ошибку с диапазоном

$$
\sqrt{\frac{1.04}{2^B}} ;\text{–}; \sqrt{\frac{1.3}{2^B}}.
$$

---

## 2. Этап 1. Инфраструктура

### 2.1. Генератор потока `RandomStreamGen`

**Цель:** сгенерировать поток строк $S$ и уметь брать префикс потока, моделирующий момент времени $t$.

**Реализация генератора:**

* Строки длиной от 1 до 30 символов.
* Алфавит: латинские буквы верхнего и нижнего регистра, цифры `0–9`, символ `-`.
* Используется `std::mt19937_64` и равномерные распределения по длине и по алфавиту.
* Реализованы методы получения префикса по доле потока (5%, 10%, …, 100%) и по количеству элементов.

### 2.2. Хеш‑функция `HashFuncGen`

**Цель:** реализовать хеш‑функцию

$$
h: U \to {0, \dots, 2^{32}-1},
$$

чтобы значения хеша были близки к равномерным по 32‑битному диапазону.

В проекте использован 32‑битный FNV‑1a, который широко применяется как быстрый строковый хеш и подходит для потоковых экспериментов на случайных строках.

---

## 3. Этап 2. Стандартный HyperLogLog

### 3.1. Параметры и структура

Параметры алгоритма:

* $B$ — число бит для выбора регистра;
* $m = 2^B$ — число регистров $M[0, \dots, m-1]$.

Каждый регистр хранит максимум наблюдаемого значения $\rho$, связанного с числом ведущих нулей в «хвосте» хеша.

### 3.2. Обработка элемента

Для элемента $s$ вычисляется $x = h(s)$, затем:

1. Индекс регистра $\text{idx}$ берётся из старших $B$ бит 32‑битного хеша.

2. По оставшимся $32-B$ битам считается

   $$
   \rho = 1 + \text{leadingZeros}(\cdot).
   $$

3. Выполняется обновление

   $$
   M[\text{idx}] = \max(M[\text{idx}], \rho).
   $$

### 3.3. Формула оценки

После обработки потока оценка кардинальности вычисляется как

$$
Z = \left( \sum_{j=0}^{m-1} 2^{-M[j]} \right)^{-1},
$$

$$
E = \alpha_m \cdot m^2 \cdot Z,
$$

где $\alpha_m$ — нормировочная константа. Для $m \ge 128$ используется формула

$$
\alpha_m = \frac{0.7213}{1 + 1.079 / m}.
$$

В данной работе использовалась базовая версия оценки без дополнительных корректировок для малых и очень больших кардинальностей, чтобы исследовать поведение стандартного алгоритма.

### 3.4. Выбор $B$

В экспериментах использовано $B = 10$, то есть $m = 1024$ регистра. Теоретическая стандартная относительная ошибка при этом порядка

$$
\frac{1.04}{\sqrt{1024}} \approx 3.25%.
$$

Это соответствует ожидаемому диапазону из условия.

### 3.5. Точное значение $F_0^t$

Для каждого префикса потока точное количество уникальных элементов $F_0^t$ вычислялось через `std::unordered_set<std::string>` как размер множества элементов префикса. Это значение использовалось как эталон при сравнении с оценкой $N_t$.

---

## 4. Эксперименты и графики

### 4.1. Настройка

Сгенерированы 5 независимых потоков длиной 100 000 строк каждый. Рассматривались префиксы от 5% до 100% с шагом 5%. Для каждого префикса вычислялись $F_0^t$ и $N_t$.

Результаты сохранялись в `results_streams.csv`, а также агрегировались по потокам в `stats_by_ratio.csv` (среднее и стандартное отклонение оценки).

### 4.2. График №1: сравнение $N_t$ и $F_0^t$

Для каждого из пяти потоков показаны кривые точного числа уникальных элементов $F_0^t$ и оценки $N_t$ по мере роста доли обработанного потока. Визуально $N_t$ хорошо повторяет динамику $F_0^t$, а отклонения относительно масштаба осей невелики.

**Интерпретация:** алгоритм корректно отслеживает рост числа уникальных элементов и даёт оценки, близкие к истинным значениям.

### 4.3. Относительная оценка $N_t / F_0^t$

Для потока `stream_id = 0` построено отношение

$$
\frac{N_t}{F_0^t}
$$

в зависимости от доли потока. Отношение колеблется около 1 и находится примерно в диапазоне 0.97–1.06, а начиная с 20–30% становится более стабильным.

**Интерпретация:** характер колебаний соответствует вероятностной природе HyperLogLog и ожидаемой ошибке порядка нескольких процентов при $m = 1024$.

### 4.4. График №2: $E(N_t)$ и область $E(N_t) \pm \sigma_{N_t}$

Построен график средних по потокам значений: $\overline{F_0^t}$ (точное среднее), $E(N_t)$ (средняя оценка) и область неопределённости

$$
E(N_t) \pm \sigma_{N_t}.
$$

На всём диапазоне $t$ линия $E(N_t)$ идёт близко к $\overline{F_0^t}$, а закрашенная область остаётся узкой, что указывает на малый разброс результатов между потоками.

---

## 5. Этап 3. Анализ точности и стабильности

### 5.1. Сопоставление с теорией

При $B = 10$ ($m = 1024$) ожидаемая стандартная относительная ошибка порядка $3.25%$. По экспериментальным графикам видно, что отклонения оценки от истинного значения остаются в пределах нескольких процентов и не выходят за рамки порядка 6%.

Это качественно соответствует теоретическим границам

$$
\sqrt{\frac{1.04}{2^B}} ;\text{–}; \sqrt{\frac{1.3}{2^B}}.
$$

### 5.2. Стабильность и дисперсия

Полоса $E(N_t) \pm \sigma_{N_t}$ остаётся узкой по всей оси времени, что означает небольшой разброс оценок между потоками. Такое поведение согласуется с тем, что точность HyperLogLog определяется главным образом числом регистров $m$ и не ухудшается при увеличении длины потока.

### 5.3. Практические выводы по параметрам

Выбор $B = 10$ обеспечивает баланс между памятью (1024 регистра) и точностью на потоках длины $10^5$. Нормировочная константа $\alpha_m$ использована в стандартном виде для $m \ge 128$, что соответствует оригинальному анализу HyperLogLog.

---

## 6. Структура проекта и запуск

**Основные файлы проекта:**

* `RandomStreamGen.h/.cpp` — генерация потоков строк и получение префиксов.
* `HashFuncGen.h/.cpp` — хеш‑функция (FNV‑1a, 32‑бит).
* `HyperLogLog.h/.cpp` — реализация HyperLogLog (`add`, `estimate`, регистры).
* `ExactDistinct.h` — точный подсчёт $F_0^t$ через `unordered_set`.
* `main.cpp` — запуск экспериментов, формирование CSV.
* `plots_hll.py` — построение графиков по CSV.
